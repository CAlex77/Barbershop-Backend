package com.barbershop.backend.service

import com.barbershop.backend.dto.request.AppointmentCreateRequest
import com.barbershop.backend.dto.response.AppointmentResponse
import com.barbershop.backend.dto.response.AvailabilitySlotResponse
import com.barbershop.backend.entity.Appointment
import com.barbershop.backend.exception.ConflictException
import com.barbershop.backend.exception.NotFoundException
import com.barbershop.backend.mapper.toResponse
import com.barbershop.backend.repository.*
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDate

@Service
class AvailabilityService(
    private val appointmentRepository: AppointmentRepository,
    private val serviceRepository: ServiceRepository,
) {
    fun getSlots(
        barberId: Long,
        date: LocalDate,
        serviceId: Long,
        stepMinutes: Int? = 15,
        tz: String? = "America/Sao_Paulo"
    ): List<AvailabilitySlotResponse> {
        // ensure service exists (for better 404)
        if (!serviceRepository.existsById(serviceId)) {
            throw NotFoundException("Service $serviceId not found")
        }
        val step = stepMinutes ?: 15
        val zone = tz ?: "America/Sao_Paulo"
        return appointmentRepository
            .availableSlots(barberId, date, serviceId, step, zone)
            .map { it.toResponse() }
    }
}

@Service
class AppointmentService(
    private val appointmentRepository: AppointmentRepository,
    private val clientRepository: ClientRepository,
    private val barberRepository: BarberRepository,
    private val serviceRepository: ServiceRepository
) {
    @Transactional
    fun create(req: AppointmentCreateRequest): AppointmentResponse {
        // validate existence for better UX
        if (!clientRepository.existsById(req.clientId)) throw NotFoundException("Client ${req.clientId} not found")
        if (!barberRepository.existsById(req.barberId)) throw NotFoundException("Barber ${req.barberId} not found")
        if (!serviceRepository.existsById(req.serviceId)) throw NotFoundException("Service ${req.serviceId} not found")

        val booked = appointmentRepository.bookAppointment(
            clientId = req.clientId,
            barberId = req.barberId,
            serviceId = req.serviceId,
            startTime = req.startTime,
            tz = req.tz ?: "America/Sao_Paulo"
        ) ?: throw ConflictException("Time slot not available")

        val entity = appointmentRepository.findById(booked.getAppointmentId())
            .orElseThrow { NotFoundException("Appointment ${booked.getAppointmentId()} not found after booking") }
        return entity.toResponse()
    }

    fun get(id: Long): AppointmentResponse {
        val a = appointmentRepository.findById(id).orElseThrow { NotFoundException("Appointment $id not found") }
        // end_time is generated by trigger; ensure not null
        return a.toResponse()
    }

    @Transactional
    fun cancel(id: Long) {
        val appt: Appointment = appointmentRepository.findById(id).orElseThrow { NotFoundException("Appointment $id not found") }
        appt.status = "CANCELED"
        // save flush only if needed; JPA dirty checking will persist
    }
}

